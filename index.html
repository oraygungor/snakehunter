<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Snake and the Hunter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');

        :root {
            --bg-color: #050510;
            --grid-line: rgba(255, 255, 255, 0.05);
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff9d;
            --neon-red: #ff4d4d;
        }

        body {
            background-color: var(--bg-color);
            color: #e0e0e0;
            font-family: 'Rajdhani', sans-serif;
            overflow-x: hidden;
            touch-action: manipulation; /* Prevent Zoom */
            -webkit-tap-highlight-color: transparent;
        }

        .font-orbitron { font-family: 'Orbitron', sans-serif; }

        /* Canvas Effects */
        canvas {
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.1);
            border-radius: 12px;
            background: radial-gradient(circle at center, #0a0a1a 0%, #000000 100%);
        }

        /* Neon Buttons */
        .btn-neon {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        
        .btn-neon::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .btn-neon:active::after {
            left: 100%;
            transition: 0s;
        }

        .glass-panel {
            background: rgba(20, 20, 35, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        /* Animations */
        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0.5; }
            100% { transform: scale(1.4); opacity: 0; }
        }

        .pulse-dot {
            position: absolute;
            border-radius: 50%;
            animation: pulse-ring 1.5s infinite;
            pointer-events: none;
        }

        /* Selection Bubble */
        .choice-bubble {
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0) translateY(10px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Header / Scoreboard -->
    <header class="w-full max-w-lg mb-4 flex justify-between items-end">
        <div>
            <h1 class="text-xl md:text-2xl font-orbitron font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 leading-tight">
                THE SNAKE AND<br>THE HUNTER
            </h1>
            <div class="text-xs text-gray-400 tracking-wider mt-1">TACTICAL GRAPH GAME</div>
        </div>
        <div class="text-right">
            <div class="text-xs text-gray-500 uppercase tracking-widest mb-1">SCORES</div>
            <div class="flex gap-3 text-sm font-bold">
                <div class="flex flex-col items-center">
                    <span class="text-[10px] text-cyan-400">P1 SNAKE</span>
                    <span id="scoreP1" class="text-xl leading-none">-</span>
                </div>
                <div class="w-px h-8 bg-gray-700"></div>
                <div class="flex flex-col items-center">
                    <span class="text-[10px] text-pink-400">P2 SNAKE</span>
                    <span id="scoreP2" class="text-xl leading-none">-</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Game Container -->
    <main class="relative w-full max-w-lg aspect-square mb-6">
        <!-- Canvas -->
        <canvas id="gameCanvas" class="w-full h-full border border-white/10 cursor-pointer select-none touch-none"></canvas>

        <!-- Dynamic Ambiguity Menu (Floating) -->
        <div id="choiceMenu" class="absolute hidden flex-col gap-2 z-10 transform -translate-x-1/2 -translate-y-full pb-4" style="left: 50%; top: 50%;">
            <button id="btnHead" class="choice-bubble bg-cyan-900/90 border border-cyan-400 text-cyan-100 px-4 py-2 rounded-full text-sm font-bold shadow-[0_0_15px_rgba(0,243,255,0.4)] whitespace-nowrap active:scale-95">
                ADD TO HEAD
            </button>
            <button id="btnTail" class="choice-bubble bg-pink-900/90 border border-pink-400 text-pink-100 px-4 py-2 rounded-full text-sm font-bold shadow-[0_0_15px_rgba(255,0,255,0.4)] whitespace-nowrap active:scale-95">
                ADD TO TAIL
            </button>
            <!-- Arrow -->
            <div class="w-3 h-3 bg-white/20 rotate-45 absolute bottom-2 left-1/2 -translate-x-1/2 border-r border-b border-white/10"></div>
        </div>

        <!-- Overlay Messages (Round End etc) -->
        <div id="overlay" class="absolute inset-0 bg-black/80 backdrop-blur-sm hidden flex-col items-center justify-center text-center p-6 rounded-xl z-20">
            <h2 id="overlayTitle" class="text-3xl font-orbitron font-bold text-white mb-2">ROUND OVER</h2>
            <p id="overlayMsg" class="text-gray-300 mb-6">No moves left.</p>
            <button id="overlayBtn" class="bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:shadow-cyan-500/30 transition transform active:scale-95">
                CONTINUE
            </button>
        </div>
    </main>

    <!-- Controls & Info -->
    <div class="w-full max-w-lg glass-panel p-4 flex flex-col gap-3">
        
        <!-- Status Bar -->
        <div class="flex justify-between items-center border-b border-white/5 pb-3">
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500 uppercase">ROUND:</span>
                <span id="roundIndicator" class="text-sm font-bold text-white">1/2</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500 uppercase">TURN:</span>
                <span id="turnIndicator" class="px-2 py-0.5 rounded text-xs font-bold bg-cyan-500/20 text-cyan-300 border border-cyan-500/30">
                    SNAKE (MAX)
                </span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500 uppercase">LENGTH:</span>
                <span id="lengthIndicator" class="text-lg font-mono font-bold text-yellow-400">0</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="grid grid-cols-2 gap-3">
            <button id="undoBtn" class="btn-neon bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 py-3 rounded-lg text-sm font-semibold flex items-center justify-center gap-2 disabled:opacity-30 disabled:cursor-not-allowed">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M3 10h10a8 8 0 018 8v2M3 10l6 6m-6-6l6-6"></path></svg>
                UNDO
            </button>
            <button id="resetBtn" class="btn-neon bg-red-500/10 hover:bg-red-500/20 border border-red-500/30 text-red-300 py-3 rounded-lg text-sm font-semibold flex items-center justify-center gap-2">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                RESET
            </button>
        </div>

        <div class="text-[10px] text-gray-600 text-center mt-1">
            Tip: Pick two adjacent points for the first move. Then extend only from the ends.
        </div>
    </div>

    <!-- Reference Footer -->
    <div class="mt-4 text-[10px] text-gray-500 text-center">
        Original puzzle: <a href="https://puzzling.stackexchange.com/questions/125611/the-snake-and-the-hunter" target="_blank" class="text-cyan-500/50 hover:text-cyan-400 underline decoration-cyan-500/30">Stack Exchange</a>
    </div>

    <!-- Grid Size Settings (Hidden by default, simplistic toggle) -->
    <div class="fixed top-4 right-4 z-50">
        <select id="gridSizeSelect" class="bg-black/80 text-gray-400 text-xs border border-white/20 rounded p-1 backdrop-blur focus:outline-none">
            <option value="4">4x4 (Easy)</option>
            <option value="5">5x5 (Medium)</option>
            <option value="6" selected>6x6 (Standard)</option>
            <option value="7">7x7 (Hard)</option>
            <option value="8">8x8 (Expert)</option>
        </select>
    </div>

<script>
{
/**
 * THE SNAKE AND THE HUNTER - Logic Controller
 */

// --- Game Configuration & State ---
let N = 6; // Grid size
let canvas, ctx;
let canvasSize, cellSize, padding;
let dpr = window.devicePixelRatio || 1;

// Game State
let path = [];     // Array of vertex indices
let used = new Set(); // Set of used vertex indices
let history = [];  // Undo stack
let round = 1;     // 1 or 2
let turnRole = 'Snake'; // 'Snake' (Maximizer) or 'Hunter' (Minimizer)
let isRoundActive = true;
let startPick = null; // First vertex of the first move

// UI State
let pendingAmbiguity = null; // {v, r, c} if user clicks a node connected to both ends

// Player Mapping: Round 1 -> P1 is Snake. Round 2 -> P2 is Snake.
const getSnakePlayer = () => round === 1 ? 1 : 2;
const getHunterPlayer = () => round === 1 ? 2 : 1;

// --- Helper Functions ---
const vid = (r, c) => r * N + c;
const rc = (v) => ({ r: Math.floor(v / N), c: v % N });

const getNeighbors = (v) => {
    const { r, c } = rc(v);
    const n = [];
    if (r > 0) n.push(vid(r - 1, c));
    if (r < N - 1) n.push(vid(r + 1, c));
    if (c > 0) n.push(vid(r, c - 1));
    if (c < N - 1) n.push(vid(r, c + 1));
    return n;
};

// --- Core Game Logic ---

function initGame() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // Resize Observer for responsiveness
    new ResizeObserver(() => {
        resizeCanvas();
        draw();
    }).observe(canvas);
    
    // Event Listeners
    canvas.addEventListener('pointerdown', handleInput);
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('resetBtn').addEventListener('click', resetMatch);
    document.getElementById('overlayBtn').addEventListener('click', nextRoundOrReset);
    document.getElementById('btnHead').addEventListener('click', () => resolveAmbiguity('head'));
    document.getElementById('btnTail').addEventListener('click', () => resolveAmbiguity('tail'));
    document.getElementById('gridSizeSelect').addEventListener('change', (e) => {
        N = parseInt(e.target.value);
        resetMatch();
    });

    resizeCanvas();
    resetMatch();
}

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvasSize = rect.width;
    canvas.width = canvasSize * dpr;
    canvas.height = canvasSize * dpr;
    ctx.scale(dpr, dpr);
    
    padding = canvasSize * 0.1; // 10% padding
    cellSize = (canvasSize - 2 * padding) / (N - 1);
}

function getCoord(v) {
    const { r, c } = rc(v);
    return {
        x: padding + c * cellSize,
        y: padding + r * cellSize
    };
}

function resetMatch() {
    round = 1;
    document.getElementById('scoreP1').textContent = '-';
    document.getElementById('scoreP2').textContent = '-';
    startRound();
}

function startRound() {
    path = [];
    used = new Set();
    history = [];
    startPick = null;
    turnRole = 'Snake';
    isRoundActive = true;
    closeMenu();
    hideOverlay();
    updateUI();
    draw();
}

function checkGameState() {
    // Check legal moves
    const head = path[0];
    const tail = path[path.length - 1];
    
    const headMoves = getNeighbors(head).filter(n => !used.has(n));
    const tailMoves = getNeighbors(tail).filter(n => !used.has(n));
    
    if (headMoves.length === 0 && tailMoves.length === 0) {
        endRound();
    }
}

function endRound() {
    isRoundActive = false;
    const score = Math.max(0, path.length - 1);
    
    // Record Score
    if (round === 1) {
        document.getElementById('scoreP1').textContent = score;
        showOverlay(`ROUND 1 OVER`, `P1 (Snake) Score: ${score}`, "START ROUND 2");
    } else {
        document.getElementById('scoreP2').textContent = score;
        // Determine Winner
        const p1Score = parseInt(document.getElementById('scoreP1').textContent);
        const p2Score = score;
        
        let msg = "";
        let color = "";
        if (p1Score > p2Score) msg = "WINNER: PLAYER 1";
        else if (p2Score > p1Score) msg = "WINNER: PLAYER 2";
        else msg = "DRAW!";
        
        showOverlay("MATCH RESULT", msg, "NEW MATCH");
    }
    draw();
}

function nextRoundOrReset() {
    if (round === 1) {
        round = 2;
        startRound();
    } else {
        resetMatch();
    }
}

// --- Interaction Logic ---

function handleInput(e) {
    if (!isRoundActive) return;
    
    // Coordinates
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Find closest node
    let closestV = -1;
    let minD = cellSize * 0.45; // Hit radius
    
    for (let i = 0; i < N * N; i++) {
        const p = getCoord(i);
        const dist = Math.sqrt((p.x - x)**2 + (p.y - y)**2);
        if (dist < minD) {
            closestV = i;
            break;
        }
    }
    
    if (closestV === -1) {
        // Tapping empty space closes menu
        closeMenu();
        return;
    }
    
    processMove(closestV);
}

function processMove(v) {
    if (used.has(v)) return;

    // 1. First Segment Logic
    if (path.length === 0) {
        if (startPick === null) {
            startPick = v;
            draw(); // Highlight start pick
        } else {
            // Check adjacency
            if (getNeighbors(startPick).includes(v)) {
                executeMove([startPick, v], 'Hunter');
                startPick = null;
            } else {
                // Changed mind, picked new start
                startPick = v; 
                draw();
            }
        }
        return;
    }

    // 2. Extension Logic
    const head = path[0];
    const tail = path[path.length - 1];
    const neighbors = getNeighbors(v);
    
    const canHead = neighbors.includes(head);
    const canTail = neighbors.includes(tail);

    if (!canHead && !canTail) return; // Not connected

    if (canHead && canTail) {
        // Ambiguous move
        openChoiceMenu(v);
    } else if (canHead) {
        executeExtension(v, 'head');
    } else {
        executeExtension(v, 'tail');
    }
}

function openChoiceMenu(v) {
    pendingAmbiguity = v;
    const coords = getCoord(v);
    const menu = document.getElementById('choiceMenu');
    
    // Position menu above the node
    // canvas coordinate to CSS coordinate
    // Since canvas is 100% of container, roughly maps 1:1 if dpr handled
    const rect = canvas.getBoundingClientRect();
    const scale = rect.width / canvas.width * dpr; // Should be 1 typically with this setup
    
    // Using percentages relative to container
    const xPct = (coords.x / (canvas.width / dpr)) * 100;
    const yPct = (coords.y / (canvas.height / dpr)) * 100;

    menu.style.left = `${xPct}%`;
    menu.style.top = `${yPct}%`;
    menu.classList.remove('hidden');
    menu.classList.add('flex');
}

function closeMenu() {
    const menu = document.getElementById('choiceMenu');
    menu.classList.add('hidden');
    menu.classList.remove('flex');
    pendingAmbiguity = null;
}

function resolveAmbiguity(choice) {
    if (pendingAmbiguity !== null) {
        executeExtension(pendingAmbiguity, choice);
        closeMenu();
    }
}

function executeExtension(v, end) {
    saveState();
    if (end === 'head') {
        path.unshift(v);
    } else {
        path.push(v);
    }
    used.add(v);
    finishTurn();
}

function executeMove(newPath, nextRole) {
    saveState();
    path = newPath;
    newPath.forEach(n => used.add(n));
    finishTurn();
}

function finishTurn() {
    // Switch role
    turnRole = turnRole === 'Snake' ? 'Hunter' : 'Snake';
    checkGameState();
    updateUI();
    draw();
}

function saveState() {
    history.push({
        path: [...path],
        used: new Set(used),
        turnRole: turnRole,
        startPick: startPick
    });
}

function undoMove() {
    if (history.length === 0) return;
    const state = history.pop();
    path = state.path;
    used = state.used;
    turnRole = state.turnRole;
    startPick = state.startPick;
    isRoundActive = true;
    hideOverlay();
    closeMenu();
    updateUI();
    draw();
}

// --- UI Updates ---

function updateUI() {
    const snakePlayer = getSnakePlayer();
    const hunterPlayer = getHunterPlayer();
    const currentPlayer = turnRole === 'Snake' ? snakePlayer : hunterPlayer;
    
    const turnEl = document.getElementById('turnIndicator');
    if (turnRole === 'Snake') {
        turnEl.textContent = `SNAKE (P${snakePlayer})`;
        turnEl.className = "px-2 py-0.5 rounded text-xs font-bold bg-cyan-500/20 text-cyan-300 border border-cyan-500/30";
    } else {
        turnEl.textContent = `HUNTER (P${hunterPlayer})`;
        turnEl.className = "px-2 py-0.5 rounded text-xs font-bold bg-pink-500/20 text-pink-300 border border-pink-500/30";
    }
    
    document.getElementById('roundIndicator').textContent = `${round}/2`;
    document.getElementById('lengthIndicator').textContent = Math.max(0, path.length - 1);
    
    document.getElementById('undoBtn').disabled = history.length === 0;
}

function showOverlay(title, msg, btnText) {
    const ov = document.getElementById('overlay');
    document.getElementById('overlayTitle').textContent = title;
    document.getElementById('overlayMsg').textContent = msg;
    document.getElementById('overlayBtn').textContent = btnText;
    ov.classList.remove('hidden');
    ov.classList.add('flex');
}

function hideOverlay() {
    const ov = document.getElementById('overlay');
    ov.classList.add('hidden');
    ov.classList.remove('flex');
}

// --- Rendering ---

function draw() {
    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw Grid Lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    // Horizontal
    for(let r=0; r<N; r++) {
        const start = getCoord(vid(r, 0));
        const end = getCoord(vid(r, N-1));
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
    }
    // Vertical
    for(let c=0; c<N; c++) {
        const start = getCoord(vid(0, c));
        const end = getCoord(vid(N-1, c));
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
    }
    ctx.stroke();

    // Determine Valid Moves for Highlighting
    let validMoves = new Set();
    if (isRoundActive) {
        if (path.length === 0) {
            if (startPick === null) {
                // All nodes valid start
            } else {
                getNeighbors(startPick).forEach(n => validMoves.add(n));
            }
        } else {
            const head = path[0];
            const tail = path[path.length - 1];
            getNeighbors(head).forEach(n => !used.has(n) && validMoves.add(n));
            getNeighbors(tail).forEach(n => !used.has(n) && validMoves.add(n));
        }
    }

    // Draw Path (Glow Effect)
    if (path.length > 1) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00f3ff';
        
        ctx.lineWidth = cellSize * 0.15;
        ctx.strokeStyle = '#00f3ff';
        
        ctx.beginPath();
        const start = getCoord(path[0]);
        ctx.moveTo(start.x, start.y);
        for(let i=1; i<path.length; i++) {
            const p = getCoord(path[i]);
            ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        
        ctx.shadowBlur = 0; // Reset shadow for nodes
    }

    // Draw Nodes
    for(let i=0; i<N*N; i++) {
        const p = getCoord(i);
        const isUsed = used.has(i);
        const isStartPick = (startPick === i);
        const isValid = validMoves.has(i);
        const isEndpoint = path.length > 0 && (path[0] === i || path[path.length-1] === i);
        
        ctx.beginPath();
        
        if (isEndpoint) {
            // Endpoints: Bigger, Different Color
            ctx.arc(p.x, p.y, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = '#ff00ff'; // Neon Pink
            ctx.shadowColor = '#ff00ff';
            ctx.shadowBlur = 10;
        } else if (isUsed) {
            // Used nodes (body)
            ctx.arc(p.x, p.y, cellSize * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = '#00f3ff'; // Neon Blue
            ctx.shadowBlur = 0;
        } else if (isStartPick) {
            // First selected point
            ctx.arc(p.x, p.y, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 10;
        } else if (isValid) {
            // Valid Move Hint
            ctx.arc(p.x, p.y, cellSize * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 157, ${0.5 + Math.sin(Date.now() / 200) * 0.2})`; // Pulsing Green
            ctx.shadowColor = '#00ff9d';
            ctx.shadowBlur = 5;
        } else {
            // Empty nodes
            ctx.arc(p.x, p.y, cellSize * 0.05, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 0;
        }
        
        ctx.fill();
        ctx.shadowBlur = 0; // Reset
    }
    
    // Animate hints loop
    if (isRoundActive) {
        requestAnimationFrame(draw);
    }
}

// Start Game
initGame();
}
</script>
</body>
</html>
