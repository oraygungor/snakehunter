<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>The Snake and the Hunter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@500;700&display=swap');

        :root {
            --bg-color: #050510;
            --grid-line: rgba(255, 255, 255, 0.05);
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff9d;
            --neon-red: #ff4d4d;
        }

        body {
            background-color: var(--bg-color);
            color: #e0e0e0;
            font-family: 'Rajdhani', sans-serif;
            overflow-x: hidden;
            touch-action: manipulation; /* Prevent Zoom */
            -webkit-tap-highlight-color: transparent;
        }

        .font-orbitron { font-family: 'Orbitron', sans-serif; }

        /* Canvas Effects */
        canvas {
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-radius: 12px;
            background: radial-gradient(circle at center, #0a0a1a 0%, #000000 100%);
        }

        /* Neon Buttons */
        .btn-neon {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        
        .btn-neon::after {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: 0.5s;
        }
        
        .btn-neon:active::after {
            left: 100%;
            transition: 0s;
        }

        .glass-panel {
            background: rgba(20, 20, 35, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
        }

        /* Selection Bubble */
        .choice-bubble {
            animation: popIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        @keyframes popIn {
            from { transform: scale(0) translateY(10px); opacity: 0; }
            to { transform: scale(1) translateY(0); opacity: 1; }
        }

        select option {
            background-color: #050510;
            color: #e0e0e0;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center justify-center p-4">

    <!-- Header / Scoreboard -->
    <header class="w-full max-w-lg mb-4 flex justify-between items-end">
        <div>
            <h1 class="text-xl md:text-2xl font-orbitron font-bold text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500 leading-tight">
                THE SNAKE AND<br>THE HUNTER
            </h1>
            <div class="text-xs text-gray-400 tracking-wider mt-1">TACTICAL GRAPH GAME</div>
        </div>
        <div class="text-right">
            <div class="text-xs text-gray-500 uppercase tracking-widest mb-1">SCORES</div>
            <div class="flex gap-3 text-sm font-bold">
                <div class="flex flex-col items-center">
                    <span class="text-[10px] text-cyan-400" id="p1Label">P1 SNAKE</span>
                    <span id="scoreP1" class="text-xl leading-none">-</span>
                </div>
                <div class="w-px h-8 bg-gray-700"></div>
                <div class="flex flex-col items-center">
                    <span class="text-[10px] text-pink-400" id="p2Label">P2 SNAKE</span>
                    <span id="scoreP2" class="text-xl leading-none">-</span>
                </div>
            </div>
        </div>
    </header>

    <!-- Game Container -->
    <main class="relative w-full max-w-lg aspect-square mb-6">
        <!-- Canvas -->
        <canvas id="gameCanvas" class="w-full h-full border border-white/10 cursor-pointer select-none touch-none"></canvas>

        <!-- Dynamic Ambiguity Menu (Floating) -->
        <div id="choiceMenu" class="absolute hidden flex-col gap-2 z-10 transform -translate-x-1/2 -translate-y-full pb-4" style="left: 50%; top: 50%;">
            <button id="btnHead" class="choice-bubble bg-cyan-900/90 border border-cyan-400 text-cyan-100 px-4 py-2 rounded-full text-sm font-bold shadow-[0_0_15px_rgba(0,243,255,0.4)] whitespace-nowrap active:scale-95">
                ADD TO HEAD
            </button>
            <button id="btnTail" class="choice-bubble bg-pink-900/90 border border-pink-400 text-pink-100 px-4 py-2 rounded-full text-sm font-bold shadow-[0_0_15px_rgba(255,0,255,0.4)] whitespace-nowrap active:scale-95">
                ADD TO TAIL
            </button>
            <!-- Arrow -->
            <div class="w-3 h-3 bg-white/20 rotate-45 absolute bottom-2 left-1/2 -translate-x-1/2 border-r border-b border-white/10"></div>
        </div>

        <!-- Overlay Messages (Round End etc) -->
        <div id="overlay" class="absolute inset-0 bg-black/80 backdrop-blur-sm hidden flex-col items-center justify-center text-center p-6 rounded-xl z-20">
            <h2 id="overlayTitle" class="text-3xl font-orbitron font-bold text-white mb-2">ROUND OVER</h2>
            <p id="overlayMsg" class="text-gray-300 mb-6">No moves left.</p>
            <button id="overlayBtn" class="bg-gradient-to-r from-cyan-500 to-blue-600 text-white font-bold py-3 px-8 rounded-lg shadow-lg hover:shadow-cyan-500/30 transition transform active:scale-95">
                CONTINUE
            </button>
        </div>
    </main>

    <!-- Controls & Info -->
    <div class="w-full max-w-lg glass-panel p-4 flex flex-col gap-3">
        
        <!-- Status Bar -->
        <div class="flex justify-between items-center border-b border-white/5 pb-3">
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500 uppercase">ROUND:</span>
                <span id="roundIndicator" class="text-sm font-bold text-white">1/2</span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500 uppercase">TURN:</span>
                <span id="turnIndicator" class="px-2 py-0.5 rounded text-xs font-bold bg-cyan-500/20 text-cyan-300 border border-cyan-500/30">
                    SNAKE (MAX)
                </span>
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xs text-gray-500 uppercase">LENGTH:</span>
                <span id="lengthIndicator" class="text-lg font-mono font-bold text-yellow-400">0</span>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="grid grid-cols-2 gap-3">
            <button id="undoBtn" class="btn-neon bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 py-3 rounded-lg text-sm font-semibold flex items-center justify-center gap-2 disabled:opacity-30 disabled:cursor-not-allowed">
                UNDO
            </button>
            <button id="resetBtn" class="btn-neon bg-red-500/10 hover:bg-red-500/20 border border-red-500/30 text-red-300 py-3 rounded-lg text-sm font-semibold flex items-center justify-center gap-2">
                RESET
            </button>

            <!-- Mode Selector -->
            <div class="col-span-2 relative">
                <select id="modeSelect" class="w-full bg-white/5 hover:bg-white/10 border border-white/10 text-gray-300 py-3 rounded-lg text-sm font-semibold focus:outline-none appearance-none text-center cursor-pointer transition-colors">
                    <option value="pvp">MODE: PLAYER VS PLAYER</option>
                    <option value="pvai">MODE: PLAYER VS AI</option>
                </select>
                <!-- Custom arrow for better look -->
                <div class="absolute right-4 top-1/2 transform -translate-y-1/2 pointer-events-none text-gray-500">
                    <svg width="12" height="12" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"></path></svg>
                </div>
            </div>
        </div>

        <div class="text-[10px] text-gray-600 text-center mt-1">
            Tip: Pick two adjacent points for the first move. Then extend only from the ends.
        </div>
    </div>

    <!-- Reference Footer -->
    <div class="mt-4 text-[10px] text-gray-500 text-center">
        Original puzzle: <a href="https://puzzling.stackexchange.com/questions/125611/the-snake-and-the-hunter" target="_blank" class="text-cyan-500/50 hover:text-cyan-400 underline decoration-cyan-500/30">Stack Exchange</a>
    </div>

    <!-- Grid Size Settings (Hidden by default, simplistic toggle) -->
    <div class="fixed top-4 right-4 z-50">
        <select id="gridSizeSelect" class="bg-black/80 text-gray-400 text-xs border border-white/20 rounded p-1 backdrop-blur focus:outline-none">
            <option value="4">4x4 (Easy)</option>
            <option value="5">5x5 (Medium)</option>
            <option value="6" selected>6x6 (Standard)</option>
            <option value="7">7x7 (Hard)</option>
            <option value="8">8x8 (Expert)</option>
        </select>
    </div>

<script>
{
/**
 * THE SNAKE AND THE HUNTER - Logic Controller
 */

// --- Game Configuration & State ---
let N = 6; // Grid size
let canvas, ctx;
let canvasSize, cellSize, padding;
let dpr = window.devicePixelRatio || 1;

// Colors
const COLOR_SNAKE = '#00f3ff'; // Cyan
const COLOR_HUNTER = '#ff00ff'; // Magenta/Pink

// AI Configuration
let playVsAI = false;           // Toggled by selector
let aiRole = "Hunter";          // "Snake" or "Hunter" (Dynamic based on round)
let aiThinking = false;
const AI_TIME_MS = 1000;        // 1 second thinking time
const AI_MAX_ITERS = 20000000;     // 20k iterations

// Game State
let path = [];     // Array of vertex indices
let used = new Set(); // Set of used vertex indices
let nodeData = {}; // Map v -> { role: 'Snake'|'Hunter', turn: int }
let history = [];  // Undo stack
let round = 1;     // 1 or 2
let turnRole = 'Snake'; // 'Snake' (Maximizer) or 'Hunter' (Minimizer)
let isRoundActive = true;
let startPick = null; // First vertex of the first move
let moveCount = 0; // Increments with every successful move
let rafId = null; // Animation frame ID

// UI State
let pendingAmbiguity = null; // {v, r, c} if user clicks a node connected to both ends

// Player Mapping: Round 1 -> P1 is Snake. Round 2 -> P2 is Snake.
const getSnakePlayer = () => round === 1 ? 1 : 2;
const getHunterPlayer = () => round === 1 ? 2 : 1;

// --- Helper Functions ---
const vid = (r, c) => r * N + c;
const rc = (v) => ({ r: Math.floor(v / N), c: v % N });

const getNeighbors = (v) => {
    const { r, c } = rc(v);
    const n = [];
    if (r > 0) n.push(vid(r - 1, c));
    if (r < N - 1) n.push(vid(r + 1, c));
    if (c > 0) n.push(vid(r, c - 1));
    if (c < N - 1) n.push(vid(r, c + 1));
    return n;
};

// --- Core Game Logic ---

function initGame() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // Resize Observer for responsiveness
    new ResizeObserver(() => {
        resizeCanvas();
        draw();
    }).observe(canvas);
    
    // Event Listeners
    canvas.addEventListener('pointerdown', handleInput);
    document.getElementById('undoBtn').addEventListener('click', undoMove);
    document.getElementById('resetBtn').addEventListener('click', resetMatch);
    document.getElementById('overlayBtn').addEventListener('click', nextRoundOrReset);
    document.getElementById('btnHead').addEventListener('click', () => resolveAmbiguity('head'));
    document.getElementById('btnTail').addEventListener('click', () => resolveAmbiguity('tail'));
    document.getElementById('gridSizeSelect').addEventListener('change', (e) => {
        N = parseInt(e.target.value);
        resetMatch();
    });

    // Mode Selector Listener
    document.getElementById('modeSelect').addEventListener('change', (e) => {
        playVsAI = (e.target.value === 'pvai');
        resetMatch();
    });

    resizeCanvas();
    resetMatch();
}

function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvasSize = rect.width;
    canvas.width = Math.floor(canvasSize * dpr);
    canvas.height = Math.floor(canvasSize * dpr);
    
    // Reset transform to prevent accumulation issues
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.scale(dpr, dpr);
    
    padding = canvasSize * 0.1; // 10% padding
    cellSize = (canvasSize - 2 * padding) / (N - 1);
}

function getCoord(v) {
    const { r, c } = rc(v);
    return {
        x: padding + c * cellSize,
        y: padding + r * cellSize
    };
}

function resetMatch() {
    round = 1;
    document.getElementById('scoreP1').textContent = '-';
    document.getElementById('scoreP2').textContent = '-';
    
    // Reset Label Names based on mode
    if (playVsAI) {
        document.getElementById('p1Label').textContent = "PLAYER SNAKE";
        document.getElementById('p2Label').textContent = "AI SNAKE";
    } else {
        document.getElementById('p1Label').textContent = "P1 SNAKE";
        document.getElementById('p2Label').textContent = "P2 SNAKE";
    }

    startRound();
}

function startRound() {
    path = [];
    used = new Set();
    nodeData = {};
    history = [];
    startPick = null;
    turnRole = 'Snake';
    moveCount = 0;
    isRoundActive = true;
    closeMenu();
    hideOverlay();
    
    // Determine AI Role if in PvAI mode
    if (playVsAI) {
        // Round 1: Player (P1) is Snake, AI (P2) is Hunter
        // Round 2: AI (P2) is Snake, Player (P1) is Hunter
        aiRole = (round === 1) ? 'Hunter' : 'Snake';
    }

    updateUI();
    draw();
    
    // Attempt AI move if AI is Snake (starts first in Round 2)
    setTimeout(() => maybeAIMove(), 100);
}

// --- AI LOGIC (MCTS) ---

function maybeAIMove(force=false) {
    if (!playVsAI && !force) return;
    if (!isRoundActive) return;
    if (aiThinking) return;
    if (!force && turnRole !== aiRole) return;

    // Small delay for UX
    setTimeout(() => aiMakeMove(), 50);
}

function aiMakeMove() {
    if (!isRoundActive) return;
    aiThinking = true;

    // Build a compact state snapshot
    const state = exportStateForAI();

    // Run MCTS to choose a move
    const move = mctsChooseMove(state, AI_TIME_MS, AI_MAX_ITERS);

    aiThinking = false;
    if (!move) return;

    // Apply chosen move to the real game
    applyAIMoveToGame(move);
}

function exportStateForAI() {
    let mask = 0n;
    for (const v of used) mask |= (1n << BigInt(v));

    return {
        N,
        path: [...path],       
        mask,                  
        turn: turnRole,        
        startPick: startPick,  
    };
}

function isBitSet(mask, v) {
    return (mask & (1n << BigInt(v))) !== 0n;
}

function setBit(mask, v) {
    return mask | (1n << BigInt(v));
}

function aiLegalMoves(st) {
    const moves = [];

    // If no snake yet: must place first edge
    if (st.path.length === 0) {
        if (st.startPick !== null) {
            // If user already picked a start, AI completes the edge
            const nbs = getNeighbors(st.startPick);
            for (const b of nbs) {
                if (!isBitSet(st.mask, b)) {
                    moves.push({ kind: "init", a: st.startPick, b });
                }
            }
        } else {
            // AI chooses a fresh edge from scratch.
            for (let a = 0; a < st.N * st.N; a++) {
                if (isBitSet(st.mask, a)) continue;
                const nbs = getNeighbors(a);
                for (const b of nbs) {
                    if (a < b && !isBitSet(st.mask, b)) {
                        moves.push({ kind: "init", a, b });
                    }
                }
            }
        }
        return moves;
    }

    const head = st.path[0];
    const tail = st.path[st.path.length - 1];

    // extend head
    for (const nb of getNeighbors(head)) {
        if (!isBitSet(st.mask, nb)) {
            moves.push({ kind: "extend", end: "head", v: nb });
        }
    }

    // extend tail
    for (const nb of getNeighbors(tail)) {
        if (!isBitSet(st.mask, nb)) {
            moves.push({ kind: "extend", end: "tail", v: nb });
        }
    }

    return moves;
}

function aiApplyMove(st, mv) {
    const nxt = {
        N: st.N,
        path: [...st.path],
        mask: st.mask,
        turn: st.turn === "Snake" ? "Hunter" : "Snake",
        startPick: st.startPick
    };

    if (mv.kind === "pickStart") {
        nxt.startPick = mv.v;
        nxt.turn = st.turn; 
        return nxt;
    }

    if (mv.kind === "init") {
        nxt.path = [mv.a, mv.b];
        nxt.mask = setBit(setBit(nxt.mask, mv.a), mv.b);
        nxt.startPick = null;
        return nxt;
    }

    // extend move
    if (mv.end === "head") nxt.path.unshift(mv.v);
    else nxt.path.push(mv.v);

    nxt.mask = setBit(nxt.mask, mv.v);
    return nxt;
}

function aiTerminal(st) {
    if (st.path.length <= 1) return false;
    const head = st.path[0];
    const tail = st.path[st.path.length - 1];

    let headFree = false;
    for (const nb of getNeighbors(head)) {
        if (!isBitSet(st.mask, nb)) { headFree = true; break; }
    }
    let tailFree = false;
    for (const nb of getNeighbors(tail)) {
        if (!isBitSet(st.mask, nb)) { tailFree = true; break; }
    }
    return !headFree && !tailFree;
}

function snakeLength(st) {
    return Math.max(0, st.path.length - 1);
}

// MCTS Node
class MCTSNode {
    constructor(state, parent=null, move=null, rootPlayer="Snake") {
        this.state = state;
        this.parent = parent;
        this.move = move;
        this.children = [];
        this.untried = aiLegalMoves(state);
        this.visits = 0;
        this.total = 0;           
        this.rootPlayer = rootPlayer;
    }
}

function uctScore(child, parentVisits, c=1.414) {
    if (child.visits === 0) return Infinity;
    return (child.total / child.visits) + c * Math.sqrt(Math.log(parentVisits) / child.visits);
}

function rewardFromRootPerspective(rootPlayer, finalLength) {
    // Snake wants MAX length, Hunter wants MIN length
    return (rootPlayer === "Snake") ? finalLength : -finalLength;
}

function rollout(state, rootPlayer) {
    let st = state;
    let guard = 0;

    while (!aiTerminal(st) && guard < 2000) {
        guard++;
        const moves = aiLegalMoves(st);
        if (moves.length === 0) break;

        // Heuristic rollout: prefer high degree for Snake, low degree for Hunter
        const isSnakeTurn = (st.turn === "Snake");
        let best = null;
        let bestScore = -1e9;
        
        const samples = Math.min(6, moves.length);
        
        for (let k = 0; k < samples; k++) {
            const mv = moves[(Math.random() * moves.length) | 0];
            let score = Math.random(); 

            if (mv.kind === "extend") {
                const nbs = getNeighbors(mv.v);
                let freeDeg = 0;
                for (const nb of nbs) if (!isBitSet(st.mask, nb)) freeDeg++;
                
                if (isSnakeTurn) score += freeDeg * 0.5;
                else score += (4 - freeDeg) * 0.5;
            }
            
            if (score > bestScore) {
                bestScore = score;
                best = mv;
            }
        }

        st = aiApplyMove(st, best);
    }

    const L = snakeLength(st);
    return rewardFromRootPerspective(rootPlayer, L);
}

function mctsChooseMove(rootState, timeMs=1000, maxIters=20000) {
    const legal = aiLegalMoves(rootState);
    if (legal.length === 0) return null;
    if (legal.length === 1) return legal[0];

    const rootPlayer = rootState.turn;
    const root = new MCTSNode(rootState, null, null, rootPlayer);

    const t0 = performance.now();
    let iters = 0;

    while ((performance.now() - t0) < timeMs && iters < maxIters) {
        iters++;

        // 1) Selection
        let node = root;
        while (node.untried.length === 0 && node.children.length > 0) {
            let best = null;
            let bestU = -1e9;
            for (const ch of node.children) {
                const u = uctScore(ch, node.visits + 1);
                if (u > bestU) { bestU = u; best = ch; }
            }
            node = best;
        }

        // 2) Expansion
        if (node.untried.length > 0) {
            const mv = node.untried.pop(); 
            const childState = aiApplyMove(node.state, mv);
            const child = new MCTSNode(childState, node, mv, rootPlayer);
            node.children.push(child);
            node = child;
        }

        // 3) Simulation
        const r = rollout(node.state, rootPlayer);

        // 4) Backpropagation
        while (node) {
            node.visits++;
            node.total += r;
            node = node.parent;
        }
    }

    // Pick most visited
    root.children.sort((a,b) => b.visits - a.visits);
    return root.children[0]?.move ?? null;
}

function applyAIMoveToGame(mv) {
    if (!isRoundActive) return;

    if (mv.kind === "pickStart") {
        startPick = mv.v;
        draw();
        setTimeout(() => maybeAIMove(), 50);
        return;
    }

    if (mv.kind === "init") {
        executeMove([mv.a, mv.b], 'Hunter');
        return;
    }

    if (mv.kind === "extend") {
        executeExtension(mv.v, mv.end);
        return;
    }
}

// --- End AI Logic ---

function checkGameState() {
    // Check legal moves
    const head = path[0];
    const tail = path[path.length - 1];
    
    const headMoves = getNeighbors(head).filter(n => !used.has(n));
    const tailMoves = getNeighbors(tail).filter(n => !used.has(n));
    
    if (headMoves.length === 0 && tailMoves.length === 0) {
        endRound();
    }
}

function endRound() {
    isRoundActive = false;
    const score = Math.max(0, path.length - 1);
    
    // Record Score
    if (round === 1) {
        document.getElementById('scoreP1').textContent = score;
        showOverlay(`ROUND 1 OVER`, `P1 (Snake) Score: ${score}`, "START ROUND 2");
    } else {
        document.getElementById('scoreP2').textContent = score;
        // Determine Winner
        const p1Score = parseInt(document.getElementById('scoreP1').textContent);
        const p2Score = score;
        
        let msg = "";
        
        if (playVsAI) {
            if (p1Score > p2Score) msg = "WINNER: PLAYER";
            else if (p2Score > p1Score) msg = "WINNER: AI";
            else msg = "DRAW!";
        } else {
            if (p1Score > p2Score) msg = "WINNER: PLAYER 1";
            else if (p2Score > p1Score) msg = "WINNER: PLAYER 2";
            else msg = "DRAW!";
        }
        
        showOverlay("MATCH RESULT", msg, "NEW MATCH");
    }
    draw();
}

function nextRoundOrReset() {
    if (round === 1) {
        round = 2;
        startRound();
    } else {
        resetMatch();
    }
}

// --- Interaction Logic ---

function handleInput(e) {
    if (!isRoundActive) return;
    if (playVsAI && turnRole === aiRole && aiThinking) return;

    // Coordinates
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Find closest node
    let closestV = -1;
    let minD = cellSize * 0.45; 
    let bestDist = minD;
    
    for (let i = 0; i < N * N; i++) {
        const p = getCoord(i);
        const dist = Math.sqrt((p.x - x)**2 + (p.y - y)**2);
        if (dist < bestDist) {
            bestDist = dist;
            closestV = i;
        }
    }
    
    if (closestV === -1) {
        closeMenu();
        return;
    }
    
    processMove(closestV);
}

function processMove(v) {
    if (used.has(v)) return;

    // 1. First Segment Logic
    if (path.length === 0) {
        if (startPick === null) {
            startPick = v;
            draw(); // Highlight start pick
        } else {
            if (getNeighbors(startPick).includes(v)) {
                executeMove([startPick, v], 'Hunter');
                startPick = null;
            } else {
                startPick = v; 
                draw();
            }
        }
        return;
    }

    // 2. Extension Logic
    const head = path[0];
    const tail = path[path.length - 1];
    const neighbors = getNeighbors(v);
    
    const canHead = neighbors.includes(head);
    const canTail = neighbors.includes(tail);

    if (!canHead && !canTail) return; 

    if (canHead && canTail) {
        openChoiceMenu(v);
    } else if (canHead) {
        executeExtension(v, 'head');
    } else {
        executeExtension(v, 'tail');
    }
}

function openChoiceMenu(v) {
    pendingAmbiguity = v;
    const coords = getCoord(v);
    const menu = document.getElementById('choiceMenu');
    
    // Position menu above the node
    const xPct = (coords.x / (canvas.width / dpr)) * 100;
    const yPct = (coords.y / (canvas.height / dpr)) * 100;

    menu.style.left = `${xPct}%`;
    menu.style.top = `${yPct}%`;
    menu.classList.remove('hidden');
    menu.classList.add('flex');
}

function closeMenu() {
    const menu = document.getElementById('choiceMenu');
    menu.classList.add('hidden');
    menu.classList.remove('flex');
    pendingAmbiguity = null;
}

function resolveAmbiguity(choice) {
    if (pendingAmbiguity !== null) {
        executeExtension(pendingAmbiguity, choice);
        closeMenu();
    }
}

function executeExtension(v, end) {
    saveState();
    if (end === 'head') {
        path.unshift(v);
    } else {
        path.push(v);
    }
    used.add(v);
    
    // Record who played this node
    nodeData[v] = { role: turnRole, turn: moveCount };
    moveCount++;
    
    finishTurn();
}

function executeMove(newPath, nextRole) {
    saveState();
    path = newPath;
    newPath.forEach(n => used.add(n));
    
    // Initial Move: Both nodes belong to Snake
    nodeData[newPath[0]] = { role: 'Snake', turn: 0 };
    nodeData[newPath[1]] = { role: 'Snake', turn: 0 };
    moveCount = 1; // 1 move used
    
    finishTurn();
}

function finishTurn() {
    turnRole = turnRole === 'Snake' ? 'Hunter' : 'Snake';
    checkGameState();
    updateUI();
    draw();

    // Trigger AI if it's AI's turn
    maybeAIMove();
}

function saveState() {
    history.push({
        path: [...path],
        used: new Set(used),
        nodeData: { ...nodeData }, // Clone object
        turnRole: turnRole,
        startPick: startPick,
        moveCount: moveCount
    });
}

function undoMove() {
    if (history.length === 0) return;
    const state = history.pop();
    path = state.path;
    used = state.used;
    nodeData = state.nodeData;
    turnRole = state.turnRole;
    startPick = state.startPick;
    moveCount = state.moveCount;
    
    isRoundActive = true;
    hideOverlay();
    closeMenu();
    updateUI();
    draw();
}

// --- UI Updates ---

function updateUI() {
    const snakePlayer = getSnakePlayer();
    const hunterPlayer = getHunterPlayer();
    
    const turnEl = document.getElementById('turnIndicator');
    
    // Customize text based on mode
    let snakeText = `SNAKE (P${snakePlayer})`;
    let hunterText = `HUNTER (P${hunterPlayer})`;

    if (playVsAI) {
        // Player is P1, AI is P2
        if (turnRole === 'Snake') {
             snakeText = (snakePlayer === 1) ? "SNAKE (YOU)" : "SNAKE (AI)";
        } else {
             hunterText = (hunterPlayer === 1) ? "HUNTER (YOU)" : "HUNTER (AI)";
        }
    }

    if (turnRole === 'Snake') {
        turnEl.textContent = snakeText;
        turnEl.className = "px-2 py-0.5 rounded text-xs font-bold bg-cyan-500/20 text-cyan-300 border border-cyan-500/30";
    } else {
        turnEl.textContent = hunterText;
        turnEl.className = "px-2 py-0.5 rounded text-xs font-bold bg-pink-500/20 text-pink-300 border border-pink-500/30";
    }
    
    document.getElementById('roundIndicator').textContent = `${round}/2`;
    document.getElementById('lengthIndicator').textContent = Math.max(0, path.length - 1);
    
    document.getElementById('undoBtn').disabled = history.length === 0;
}

function showOverlay(title, msg, btnText) {
    const ov = document.getElementById('overlay');
    document.getElementById('overlayTitle').textContent = title;
    document.getElementById('overlayMsg').textContent = msg;
    document.getElementById('overlayBtn').textContent = btnText;
    ov.classList.remove('hidden');
    ov.classList.add('flex');
}

function hideOverlay() {
    const ov = document.getElementById('overlay');
    ov.classList.add('hidden');
    ov.classList.remove('flex');
}

// --- Rendering ---

function draw() {
    // Clear - using logical size since we scaled, or clear physical
    ctx.clearRect(0, 0, canvasSize, canvasSize);
    
    // Draw Grid Lines
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    // Horizontal
    for(let r=0; r<N; r++) {
        const start = getCoord(vid(r, 0));
        const end = getCoord(vid(r, N-1));
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
    }
    // Vertical
    for(let c=0; c<N; c++) {
        const start = getCoord(vid(0, c));
        const end = getCoord(vid(N-1, c));
        ctx.moveTo(start.x, start.y);
        ctx.lineTo(end.x, end.y);
    }
    ctx.stroke();

    // Determine Valid Moves for Highlighting
    let validMoves = new Set();
    if (isRoundActive) {
        if (path.length === 0) {
            if (startPick === null) {
                // All nodes valid start
            } else {
                getNeighbors(startPick).forEach(n => validMoves.add(n));
            }
        } else {
            const head = path[0];
            const tail = path[path.length - 1];
            getNeighbors(head).forEach(n => !used.has(n) && validMoves.add(n));
            getNeighbors(tail).forEach(n => !used.has(n) && validMoves.add(n));
        }
    }

    // Draw Path Segments (Colored by Creator)
    if (path.length > 1) {
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.shadowBlur = 10;
        ctx.lineWidth = cellSize * 0.15;

        for (let i = 0; i < path.length - 1; i++) {
            const u = path[i];
            const v = path[i+1];
            const p1 = getCoord(u);
            const p2 = getCoord(v);
            
            // Determine who created this segment
            // The segment belongs to the node that was added LATER (higher turn number)
            const dataU = nodeData[u];
            const dataV = nodeData[v];
            
            let color = COLOR_SNAKE; // Default
            if (dataU && dataV) {
                // If both are turn 0 (init), it's Snake.
                // Otherwise, use the role of the higher turn number.
                if (dataU.turn > dataV.turn) {
                    color = dataU.role === 'Snake' ? COLOR_SNAKE : COLOR_HUNTER;
                } else {
                    color = dataV.role === 'Snake' ? COLOR_SNAKE : COLOR_HUNTER;
                }
            }

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.shadowColor = color;
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }
        
        ctx.shadowBlur = 0;
    }

    // Draw Nodes
    for(let i=0; i<N*N; i++) {
        const p = getCoord(i);
        const isUsed = used.has(i);
        const isStartPick = (startPick === i);
        const isValid = validMoves.has(i);
        const isEndpoint = path.length > 0 && (path[0] === i || path[path.length-1] === i);
        
        ctx.beginPath();
        
        if (isEndpoint) {
            // Endpoints: Bigger, Different Color
            ctx.arc(p.x, p.y, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff'; 
            ctx.shadowColor = '#ffffff';
            ctx.shadowBlur = 10;
        } else if (isUsed) {
            // Used nodes (body) - Color based on who placed them
            const data = nodeData[i];
            const color = (data && data.role === 'Hunter') ? COLOR_HUNTER : COLOR_SNAKE;
            
            ctx.arc(p.x, p.y, cellSize * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.shadowColor = color;
            ctx.shadowBlur = 5;
        } else if (isStartPick) {
            // First selected point
            ctx.arc(p.x, p.y, cellSize * 0.2, 0, Math.PI * 2);
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 10;
        } else if (isValid) {
            // Valid Move Hint
            ctx.arc(p.x, p.y, cellSize * 0.12, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 157, ${0.5 + Math.sin(Date.now() / 200) * 0.2})`; // Pulsing Green
            ctx.shadowColor = '#00ff9d';
            ctx.shadowBlur = 5;
        } else {
            // Empty nodes
            ctx.arc(p.x, p.y, cellSize * 0.05, 0, Math.PI * 2);
            ctx.fillStyle = '#333';
            ctx.shadowBlur = 0;
        }
        
        ctx.fill();
        ctx.shadowBlur = 0; // Reset
    }
    
    // Animate hints loop
    if (rafId) {
        cancelAnimationFrame(rafId);
        rafId = null;
    }
    if (isRoundActive) {
        rafId = requestAnimationFrame(draw);
    }
}

// Start Game
initGame();
}
</script>
</body>
</html>
